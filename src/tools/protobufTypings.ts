// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.33.2
// source: protobufTypings.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "zbiorkom.socket";

export enum StopTimeType {
  REGULAR = 0,
  FORBIDDEN = 1,
  ON_DEMAND = 2,
}

export function stopTimeTypeFromJSON(object: any): StopTimeType {
  switch (object) {
    case 0:
    case "REGULAR":
      return StopTimeType.REGULAR;
    case 1:
    case "FORBIDDEN":
      return StopTimeType.FORBIDDEN;
    case 2:
    case "ON_DEMAND":
      return StopTimeType.ON_DEMAND;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StopTimeType");
  }
}

export function stopTimeTypeToJSON(object: StopTimeType): string {
  switch (object) {
    case StopTimeType.REGULAR:
      return "REGULAR";
    case StopTimeType.FORBIDDEN:
      return "FORBIDDEN";
    case StopTimeType.ON_DEMAND:
      return "ON_DEMAND";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum StopTimeType");
  }
}

export enum DepartureStatus {
  /** SCHEDULED - Based on static GTFS data */
  SCHEDULED = 0,
  /** LIVE - Real-time prediction available */
  LIVE = 1,
  /** ON_PREVIOUS_TRIP - Vehicle is still on the previous trip */
  ON_PREVIOUS_TRIP = 2,
  /** DEPARTED - Vehicle has already left this stop */
  DEPARTED = 3,
  /** CANCELLED - Trip is cancelled */
  CANCELLED = 4,
}

export function departureStatusFromJSON(object: any): DepartureStatus {
  switch (object) {
    case 0:
    case "SCHEDULED":
      return DepartureStatus.SCHEDULED;
    case 1:
    case "LIVE":
      return DepartureStatus.LIVE;
    case 2:
    case "ON_PREVIOUS_TRIP":
      return DepartureStatus.ON_PREVIOUS_TRIP;
    case 3:
    case "DEPARTED":
      return DepartureStatus.DEPARTED;
    case 4:
    case "CANCELLED":
      return DepartureStatus.CANCELLED;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DepartureStatus");
  }
}

export function departureStatusToJSON(object: DepartureStatus): string {
  switch (object) {
    case DepartureStatus.SCHEDULED:
      return "SCHEDULED";
    case DepartureStatus.LIVE:
      return "LIVE";
    case DepartureStatus.ON_PREVIOUS_TRIP:
      return "ON_PREVIOUS_TRIP";
    case DepartureStatus.DEPARTED:
      return "DEPARTED";
    case DepartureStatus.CANCELLED:
      return "CANCELLED";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum DepartureStatus");
  }
}

export interface ClientMessage {
  subscribeMapFeatures?: SubscribeMapFeatures | undefined;
  subscribeStopDepartures?: SubscribeStopDepartures | undefined;
  subscribeTripUpdate?: SubscribeTripUpdate | undefined;
  unsubscribe?: Unsubscribe | undefined;
}

export interface SubscribeMapFeatures {
  city: string;
  bounds: Bounds | undefined;
  zoom: number;
  filterRoutes: string[];
  filterModels: string[];
  filterDirection?: number | undefined;
}

export interface SubscribeStopDepartures {
  city: string;
  stopId: string;
  limit: number;
  time: number;
  destinations: string[];
}

export interface SubscribeTripUpdate {
  city: string;
  tripId?: string | undefined;
  vehicleId?: string | undefined;
}

export interface Unsubscribe {
}

export interface ServerMessage {
  mapFeaturesUpdate?: MapFeaturesUpdate | undefined;
  stopDeparturesUpdate?: StopDeparturesUpdate | undefined;
  tripUpdateData?: TripUpdateData | undefined;
  error?: Error | undefined;
}

export interface Error {
  code: string;
  message?: string | undefined;
}

export interface Bounds {
  minLon: number;
  minLat: number;
  maxLon: number;
  maxLat: number;
}

export interface Route {
  id: string;
  city: string;
  name: string;
  agency?: string | undefined;
  type: number;
  color: string;
  longName?: string | undefined;
  directions: string[];
}

export interface Routes {
  routes: Route[];
}

export interface Stop {
  id: string;
  city: string;
  name: string;
  code?: string | undefined;
  location: number[];
  type: number[];
  routes: Route[];
  station: boolean;
  bearing?: number | undefined;
  direction?: string | undefined;
  exits: Exit[];
}

export interface Exit {
  name: string;
  location: number[];
}

export interface Vehicle {
  id: string;
  city: string;
  route: Route | undefined;
  brigade?: string | undefined;
  tripId?: string | undefined;
  location: number[];
  bearing?: number | undefined;
  lastPing?: number | undefined;
}

export interface MapFeaturesUpdate {
  vehicles: Vehicle[];
  dotVehicles?: DotVehicles | undefined;
  stops: Stop[];
  stopsChanged: boolean;
}

export interface DotVehicles {
  colors: string[];
  vehicles: number[];
}

export interface StopDeparturesUpdate {
  stop: Stop | undefined;
  departures: DepartureEntry[];
}

export interface DepartureEntry {
  trip: TripDetails | undefined;
  departure: DepartureEvent | undefined;
  destination?: DepartureEvent | undefined;
  position?: Vehicle | undefined;
}

export interface TripDetails {
  id: string;
  city: string;
  headsign: string;
  route: Route | undefined;
  shortName?: string | undefined;
  brigade?: string | undefined;
}

export interface DepartureEvent {
  scheduled: number;
  predicted: number;
  status: DepartureStatus;
  platform?: string | undefined;
}

export interface TripUpdateData {
  city: string;
  trip?: TripDetails | undefined;
  shape?: string | undefined;
  vehicle?: Vehicle | undefined;
  stops: TripStop[];
  sequence?: number | undefined;
  lastUpdate?: number | undefined;
}

export interface TripStop {
  stop: Stop | undefined;
  arrival: TripTime | undefined;
  departure: TripTime | undefined;
  sequence: number;
  type: StopTimeType;
  platform?: string | undefined;
  track?: string | undefined;
  alerts: string[];
}

export interface TripTime {
  scheduled: number;
  predicted: number;
  status: DepartureStatus;
}

function createBaseClientMessage(): ClientMessage {
  return {
    subscribeMapFeatures: undefined,
    subscribeStopDepartures: undefined,
    subscribeTripUpdate: undefined,
    unsubscribe: undefined,
  };
}

export const ClientMessage: MessageFns<ClientMessage> = {
  encode(message: ClientMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscribeMapFeatures !== undefined) {
      SubscribeMapFeatures.encode(message.subscribeMapFeatures, writer.uint32(10).fork()).join();
    }
    if (message.subscribeStopDepartures !== undefined) {
      SubscribeStopDepartures.encode(message.subscribeStopDepartures, writer.uint32(18).fork()).join();
    }
    if (message.subscribeTripUpdate !== undefined) {
      SubscribeTripUpdate.encode(message.subscribeTripUpdate, writer.uint32(26).fork()).join();
    }
    if (message.unsubscribe !== undefined) {
      Unsubscribe.encode(message.unsubscribe, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeMapFeatures = SubscribeMapFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeStopDepartures = SubscribeStopDepartures.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscribeTripUpdate = SubscribeTripUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unsubscribe = Unsubscribe.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientMessage {
    return {
      subscribeMapFeatures: isSet(object.subscribeMapFeatures)
        ? SubscribeMapFeatures.fromJSON(object.subscribeMapFeatures)
        : undefined,
      subscribeStopDepartures: isSet(object.subscribeStopDepartures)
        ? SubscribeStopDepartures.fromJSON(object.subscribeStopDepartures)
        : undefined,
      subscribeTripUpdate: isSet(object.subscribeTripUpdate)
        ? SubscribeTripUpdate.fromJSON(object.subscribeTripUpdate)
        : undefined,
      unsubscribe: isSet(object.unsubscribe) ? Unsubscribe.fromJSON(object.unsubscribe) : undefined,
    };
  },

  toJSON(message: ClientMessage): unknown {
    const obj: any = {};
    if (message.subscribeMapFeatures !== undefined) {
      obj.subscribeMapFeatures = SubscribeMapFeatures.toJSON(message.subscribeMapFeatures);
    }
    if (message.subscribeStopDepartures !== undefined) {
      obj.subscribeStopDepartures = SubscribeStopDepartures.toJSON(message.subscribeStopDepartures);
    }
    if (message.subscribeTripUpdate !== undefined) {
      obj.subscribeTripUpdate = SubscribeTripUpdate.toJSON(message.subscribeTripUpdate);
    }
    if (message.unsubscribe !== undefined) {
      obj.unsubscribe = Unsubscribe.toJSON(message.unsubscribe);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientMessage>, I>>(base?: I): ClientMessage {
    return ClientMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientMessage>, I>>(object: I): ClientMessage {
    const message = createBaseClientMessage();
    message.subscribeMapFeatures = (object.subscribeMapFeatures !== undefined && object.subscribeMapFeatures !== null)
      ? SubscribeMapFeatures.fromPartial(object.subscribeMapFeatures)
      : undefined;
    message.subscribeStopDepartures =
      (object.subscribeStopDepartures !== undefined && object.subscribeStopDepartures !== null)
        ? SubscribeStopDepartures.fromPartial(object.subscribeStopDepartures)
        : undefined;
    message.subscribeTripUpdate = (object.subscribeTripUpdate !== undefined && object.subscribeTripUpdate !== null)
      ? SubscribeTripUpdate.fromPartial(object.subscribeTripUpdate)
      : undefined;
    message.unsubscribe = (object.unsubscribe !== undefined && object.unsubscribe !== null)
      ? Unsubscribe.fromPartial(object.unsubscribe)
      : undefined;
    return message;
  },
};

function createBaseSubscribeMapFeatures(): SubscribeMapFeatures {
  return { city: "", bounds: undefined, zoom: 0, filterRoutes: [], filterModels: [], filterDirection: undefined };
}

export const SubscribeMapFeatures: MessageFns<SubscribeMapFeatures> = {
  encode(message: SubscribeMapFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.city !== "") {
      writer.uint32(10).string(message.city);
    }
    if (message.bounds !== undefined) {
      Bounds.encode(message.bounds, writer.uint32(18).fork()).join();
    }
    if (message.zoom !== 0) {
      writer.uint32(29).float(message.zoom);
    }
    for (const v of message.filterRoutes) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.filterModels) {
      writer.uint32(42).string(v!);
    }
    if (message.filterDirection !== undefined) {
      writer.uint32(48).int32(message.filterDirection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeMapFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeMapFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bounds = Bounds.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.zoom = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filterRoutes.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filterModels.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.filterDirection = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeMapFeatures {
    return {
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      bounds: isSet(object.bounds) ? Bounds.fromJSON(object.bounds) : undefined,
      zoom: isSet(object.zoom) ? globalThis.Number(object.zoom) : 0,
      filterRoutes: globalThis.Array.isArray(object?.filterRoutes)
        ? object.filterRoutes.map((e: any) => globalThis.String(e))
        : [],
      filterModels: globalThis.Array.isArray(object?.filterModels)
        ? object.filterModels.map((e: any) => globalThis.String(e))
        : [],
      filterDirection: isSet(object.filterDirection) ? globalThis.Number(object.filterDirection) : undefined,
    };
  },

  toJSON(message: SubscribeMapFeatures): unknown {
    const obj: any = {};
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.bounds !== undefined) {
      obj.bounds = Bounds.toJSON(message.bounds);
    }
    if (message.zoom !== 0) {
      obj.zoom = message.zoom;
    }
    if (message.filterRoutes?.length) {
      obj.filterRoutes = message.filterRoutes;
    }
    if (message.filterModels?.length) {
      obj.filterModels = message.filterModels;
    }
    if (message.filterDirection !== undefined) {
      obj.filterDirection = Math.round(message.filterDirection);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeMapFeatures>, I>>(base?: I): SubscribeMapFeatures {
    return SubscribeMapFeatures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeMapFeatures>, I>>(object: I): SubscribeMapFeatures {
    const message = createBaseSubscribeMapFeatures();
    message.city = object.city ?? "";
    message.bounds = (object.bounds !== undefined && object.bounds !== null)
      ? Bounds.fromPartial(object.bounds)
      : undefined;
    message.zoom = object.zoom ?? 0;
    message.filterRoutes = object.filterRoutes?.map((e) => e) || [];
    message.filterModels = object.filterModels?.map((e) => e) || [];
    message.filterDirection = object.filterDirection ?? undefined;
    return message;
  },
};

function createBaseSubscribeStopDepartures(): SubscribeStopDepartures {
  return { city: "", stopId: "", limit: 0, time: 0, destinations: [] };
}

export const SubscribeStopDepartures: MessageFns<SubscribeStopDepartures> = {
  encode(message: SubscribeStopDepartures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.city !== "") {
      writer.uint32(10).string(message.city);
    }
    if (message.stopId !== "") {
      writer.uint32(18).string(message.stopId);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.time !== 0) {
      writer.uint32(32).int64(message.time);
    }
    for (const v of message.destinations) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeStopDepartures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeStopDepartures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stopId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.time = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.destinations.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeStopDepartures {
    return {
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      stopId: isSet(object.stopId) ? globalThis.String(object.stopId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      time: isSet(object.time) ? globalThis.Number(object.time) : 0,
      destinations: globalThis.Array.isArray(object?.destinations)
        ? object.destinations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SubscribeStopDepartures): unknown {
    const obj: any = {};
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.stopId !== "") {
      obj.stopId = message.stopId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.time !== 0) {
      obj.time = Math.round(message.time);
    }
    if (message.destinations?.length) {
      obj.destinations = message.destinations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeStopDepartures>, I>>(base?: I): SubscribeStopDepartures {
    return SubscribeStopDepartures.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeStopDepartures>, I>>(object: I): SubscribeStopDepartures {
    const message = createBaseSubscribeStopDepartures();
    message.city = object.city ?? "";
    message.stopId = object.stopId ?? "";
    message.limit = object.limit ?? 0;
    message.time = object.time ?? 0;
    message.destinations = object.destinations?.map((e) => e) || [];
    return message;
  },
};

function createBaseSubscribeTripUpdate(): SubscribeTripUpdate {
  return { city: "", tripId: undefined, vehicleId: undefined };
}

export const SubscribeTripUpdate: MessageFns<SubscribeTripUpdate> = {
  encode(message: SubscribeTripUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.city !== "") {
      writer.uint32(10).string(message.city);
    }
    if (message.tripId !== undefined) {
      writer.uint32(18).string(message.tripId);
    }
    if (message.vehicleId !== undefined) {
      writer.uint32(26).string(message.vehicleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeTripUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTripUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tripId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.vehicleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribeTripUpdate {
    return {
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : undefined,
      vehicleId: isSet(object.vehicleId) ? globalThis.String(object.vehicleId) : undefined,
    };
  },

  toJSON(message: SubscribeTripUpdate): unknown {
    const obj: any = {};
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.tripId !== undefined) {
      obj.tripId = message.tripId;
    }
    if (message.vehicleId !== undefined) {
      obj.vehicleId = message.vehicleId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubscribeTripUpdate>, I>>(base?: I): SubscribeTripUpdate {
    return SubscribeTripUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubscribeTripUpdate>, I>>(object: I): SubscribeTripUpdate {
    const message = createBaseSubscribeTripUpdate();
    message.city = object.city ?? "";
    message.tripId = object.tripId ?? undefined;
    message.vehicleId = object.vehicleId ?? undefined;
    return message;
  },
};

function createBaseUnsubscribe(): Unsubscribe {
  return {};
}

export const Unsubscribe: MessageFns<Unsubscribe> = {
  encode(_: Unsubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unsubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Unsubscribe {
    return {};
  },

  toJSON(_: Unsubscribe): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsubscribe>, I>>(base?: I): Unsubscribe {
    return Unsubscribe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unsubscribe>, I>>(_: I): Unsubscribe {
    const message = createBaseUnsubscribe();
    return message;
  },
};

function createBaseServerMessage(): ServerMessage {
  return { mapFeaturesUpdate: undefined, stopDeparturesUpdate: undefined, tripUpdateData: undefined, error: undefined };
}

export const ServerMessage: MessageFns<ServerMessage> = {
  encode(message: ServerMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mapFeaturesUpdate !== undefined) {
      MapFeaturesUpdate.encode(message.mapFeaturesUpdate, writer.uint32(10).fork()).join();
    }
    if (message.stopDeparturesUpdate !== undefined) {
      StopDeparturesUpdate.encode(message.stopDeparturesUpdate, writer.uint32(18).fork()).join();
    }
    if (message.tripUpdateData !== undefined) {
      TripUpdateData.encode(message.tripUpdateData, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mapFeaturesUpdate = MapFeaturesUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stopDeparturesUpdate = StopDeparturesUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tripUpdateData = TripUpdateData.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = Error.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerMessage {
    return {
      mapFeaturesUpdate: isSet(object.mapFeaturesUpdate)
        ? MapFeaturesUpdate.fromJSON(object.mapFeaturesUpdate)
        : undefined,
      stopDeparturesUpdate: isSet(object.stopDeparturesUpdate)
        ? StopDeparturesUpdate.fromJSON(object.stopDeparturesUpdate)
        : undefined,
      tripUpdateData: isSet(object.tripUpdateData) ? TripUpdateData.fromJSON(object.tripUpdateData) : undefined,
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    };
  },

  toJSON(message: ServerMessage): unknown {
    const obj: any = {};
    if (message.mapFeaturesUpdate !== undefined) {
      obj.mapFeaturesUpdate = MapFeaturesUpdate.toJSON(message.mapFeaturesUpdate);
    }
    if (message.stopDeparturesUpdate !== undefined) {
      obj.stopDeparturesUpdate = StopDeparturesUpdate.toJSON(message.stopDeparturesUpdate);
    }
    if (message.tripUpdateData !== undefined) {
      obj.tripUpdateData = TripUpdateData.toJSON(message.tripUpdateData);
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerMessage>, I>>(base?: I): ServerMessage {
    return ServerMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerMessage>, I>>(object: I): ServerMessage {
    const message = createBaseServerMessage();
    message.mapFeaturesUpdate = (object.mapFeaturesUpdate !== undefined && object.mapFeaturesUpdate !== null)
      ? MapFeaturesUpdate.fromPartial(object.mapFeaturesUpdate)
      : undefined;
    message.stopDeparturesUpdate = (object.stopDeparturesUpdate !== undefined && object.stopDeparturesUpdate !== null)
      ? StopDeparturesUpdate.fromPartial(object.stopDeparturesUpdate)
      : undefined;
    message.tripUpdateData = (object.tripUpdateData !== undefined && object.tripUpdateData !== null)
      ? TripUpdateData.fromPartial(object.tripUpdateData)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null) ? Error.fromPartial(object.error) : undefined;
    return message;
  },
};

function createBaseError(): Error {
  return { code: "", message: undefined };
}

export const Error: MessageFns<Error> = {
  encode(message: Error, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== "") {
      writer.uint32(10).string(message.code);
    }
    if (message.message !== undefined) {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Error {
    return {
      code: isSet(object.code) ? globalThis.String(object.code) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: Error): unknown {
    const obj: any = {};
    if (message.code !== "") {
      obj.code = message.code;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError();
    message.code = object.code ?? "";
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseBounds(): Bounds {
  return { minLon: 0, minLat: 0, maxLon: 0, maxLat: 0 };
}

export const Bounds: MessageFns<Bounds> = {
  encode(message: Bounds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.minLon !== 0) {
      writer.uint32(9).double(message.minLon);
    }
    if (message.minLat !== 0) {
      writer.uint32(17).double(message.minLat);
    }
    if (message.maxLon !== 0) {
      writer.uint32(25).double(message.maxLon);
    }
    if (message.maxLat !== 0) {
      writer.uint32(33).double(message.maxLat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bounds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBounds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.minLon = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.minLat = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.maxLon = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.maxLat = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bounds {
    return {
      minLon: isSet(object.minLon) ? globalThis.Number(object.minLon) : 0,
      minLat: isSet(object.minLat) ? globalThis.Number(object.minLat) : 0,
      maxLon: isSet(object.maxLon) ? globalThis.Number(object.maxLon) : 0,
      maxLat: isSet(object.maxLat) ? globalThis.Number(object.maxLat) : 0,
    };
  },

  toJSON(message: Bounds): unknown {
    const obj: any = {};
    if (message.minLon !== 0) {
      obj.minLon = message.minLon;
    }
    if (message.minLat !== 0) {
      obj.minLat = message.minLat;
    }
    if (message.maxLon !== 0) {
      obj.maxLon = message.maxLon;
    }
    if (message.maxLat !== 0) {
      obj.maxLat = message.maxLat;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bounds>, I>>(base?: I): Bounds {
    return Bounds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bounds>, I>>(object: I): Bounds {
    const message = createBaseBounds();
    message.minLon = object.minLon ?? 0;
    message.minLat = object.minLat ?? 0;
    message.maxLon = object.maxLon ?? 0;
    message.maxLat = object.maxLat ?? 0;
    return message;
  },
};

function createBaseRoute(): Route {
  return { id: "", city: "", name: "", agency: undefined, type: 0, color: "", longName: undefined, directions: [] };
}

export const Route: MessageFns<Route> = {
  encode(message: Route, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.agency !== undefined) {
      writer.uint32(34).string(message.agency);
    }
    if (message.type !== 0) {
      writer.uint32(40).uint32(message.type);
    }
    if (message.color !== "") {
      writer.uint32(50).string(message.color);
    }
    if (message.longName !== undefined) {
      writer.uint32(58).string(message.longName);
    }
    for (const v of message.directions) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Route {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.agency = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.color = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.longName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.directions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Route {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      agency: isSet(object.agency) ? globalThis.String(object.agency) : undefined,
      type: isSet(object.type) ? globalThis.Number(object.type) : 0,
      color: isSet(object.color) ? globalThis.String(object.color) : "",
      longName: isSet(object.longName) ? globalThis.String(object.longName) : undefined,
      directions: globalThis.Array.isArray(object?.directions)
        ? object.directions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Route): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.agency !== undefined) {
      obj.agency = message.agency;
    }
    if (message.type !== 0) {
      obj.type = Math.round(message.type);
    }
    if (message.color !== "") {
      obj.color = message.color;
    }
    if (message.longName !== undefined) {
      obj.longName = message.longName;
    }
    if (message.directions?.length) {
      obj.directions = message.directions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Route>, I>>(base?: I): Route {
    return Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Route>, I>>(object: I): Route {
    const message = createBaseRoute();
    message.id = object.id ?? "";
    message.city = object.city ?? "";
    message.name = object.name ?? "";
    message.agency = object.agency ?? undefined;
    message.type = object.type ?? 0;
    message.color = object.color ?? "";
    message.longName = object.longName ?? undefined;
    message.directions = object.directions?.map((e) => e) || [];
    return message;
  },
};

function createBaseRoutes(): Routes {
  return { routes: [] };
}

export const Routes: MessageFns<Routes> = {
  encode(message: Routes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.routes) {
      Route.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Routes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoutes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routes.push(Route.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Routes {
    return { routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : [] };
  },

  toJSON(message: Routes): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Routes>, I>>(base?: I): Routes {
    return Routes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Routes>, I>>(object: I): Routes {
    const message = createBaseRoutes();
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStop(): Stop {
  return {
    id: "",
    city: "",
    name: "",
    code: undefined,
    location: [],
    type: [],
    routes: [],
    station: false,
    bearing: undefined,
    direction: undefined,
    exits: [],
  };
}

export const Stop: MessageFns<Stop> = {
  encode(message: Stop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.code !== undefined) {
      writer.uint32(34).string(message.code);
    }
    writer.uint32(42).fork();
    for (const v of message.location) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(50).fork();
    for (const v of message.type) {
      writer.uint32(v);
    }
    writer.join();
    for (const v of message.routes) {
      Route.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.station !== false) {
      writer.uint32(64).bool(message.station);
    }
    if (message.bearing !== undefined) {
      writer.uint32(72).int32(message.bearing);
    }
    if (message.direction !== undefined) {
      writer.uint32(82).string(message.direction);
    }
    for (const v of message.exits) {
      Exit.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Stop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.code = reader.string();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.location.push(reader.int32());

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.location.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag === 48) {
            message.type.push(reader.uint32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.type.push(reader.uint32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.routes.push(Route.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.station = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.bearing = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.exits.push(Exit.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Stop {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      code: isSet(object.code) ? globalThis.String(object.code) : undefined,
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.Number(e)) : [],
      type: globalThis.Array.isArray(object?.type) ? object.type.map((e: any) => globalThis.Number(e)) : [],
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Route.fromJSON(e)) : [],
      station: isSet(object.station) ? globalThis.Boolean(object.station) : false,
      bearing: isSet(object.bearing) ? globalThis.Number(object.bearing) : undefined,
      direction: isSet(object.direction) ? globalThis.String(object.direction) : undefined,
      exits: globalThis.Array.isArray(object?.exits) ? object.exits.map((e: any) => Exit.fromJSON(e)) : [],
    };
  },

  toJSON(message: Stop): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.code !== undefined) {
      obj.code = message.code;
    }
    if (message.location?.length) {
      obj.location = message.location.map((e) => Math.round(e));
    }
    if (message.type?.length) {
      obj.type = message.type.map((e) => Math.round(e));
    }
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Route.toJSON(e));
    }
    if (message.station !== false) {
      obj.station = message.station;
    }
    if (message.bearing !== undefined) {
      obj.bearing = Math.round(message.bearing);
    }
    if (message.direction !== undefined) {
      obj.direction = message.direction;
    }
    if (message.exits?.length) {
      obj.exits = message.exits.map((e) => Exit.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Stop>, I>>(base?: I): Stop {
    return Stop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Stop>, I>>(object: I): Stop {
    const message = createBaseStop();
    message.id = object.id ?? "";
    message.city = object.city ?? "";
    message.name = object.name ?? "";
    message.code = object.code ?? undefined;
    message.location = object.location?.map((e) => e) || [];
    message.type = object.type?.map((e) => e) || [];
    message.routes = object.routes?.map((e) => Route.fromPartial(e)) || [];
    message.station = object.station ?? false;
    message.bearing = object.bearing ?? undefined;
    message.direction = object.direction ?? undefined;
    message.exits = object.exits?.map((e) => Exit.fromPartial(e)) || [];
    return message;
  },
};

function createBaseExit(): Exit {
  return { name: "", location: [] };
}

export const Exit: MessageFns<Exit> = {
  encode(message: Exit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    writer.uint32(18).fork();
    for (const v of message.location) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Exit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.location.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.location.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exit {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: Exit): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.location?.length) {
      obj.location = message.location.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exit>, I>>(base?: I): Exit {
    return Exit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exit>, I>>(object: I): Exit {
    const message = createBaseExit();
    message.name = object.name ?? "";
    message.location = object.location?.map((e) => e) || [];
    return message;
  },
};

function createBaseVehicle(): Vehicle {
  return {
    id: "",
    city: "",
    route: undefined,
    brigade: undefined,
    tripId: undefined,
    location: [],
    bearing: undefined,
    lastPing: undefined,
  };
}

export const Vehicle: MessageFns<Vehicle> = {
  encode(message: Vehicle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.route !== undefined) {
      Route.encode(message.route, writer.uint32(26).fork()).join();
    }
    if (message.brigade !== undefined) {
      writer.uint32(34).string(message.brigade);
    }
    if (message.tripId !== undefined) {
      writer.uint32(42).string(message.tripId);
    }
    writer.uint32(50).fork();
    for (const v of message.location) {
      writer.int32(v);
    }
    writer.join();
    if (message.bearing !== undefined) {
      writer.uint32(61).float(message.bearing);
    }
    if (message.lastPing !== undefined) {
      writer.uint32(64).int64(message.lastPing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vehicle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVehicle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.route = Route.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.brigade = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tripId = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.location.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.location.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.bearing = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lastPing = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vehicle {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      route: isSet(object.route) ? Route.fromJSON(object.route) : undefined,
      brigade: isSet(object.brigade) ? globalThis.String(object.brigade) : undefined,
      tripId: isSet(object.tripId) ? globalThis.String(object.tripId) : undefined,
      location: globalThis.Array.isArray(object?.location) ? object.location.map((e: any) => globalThis.Number(e)) : [],
      bearing: isSet(object.bearing) ? globalThis.Number(object.bearing) : undefined,
      lastPing: isSet(object.lastPing) ? globalThis.Number(object.lastPing) : undefined,
    };
  },

  toJSON(message: Vehicle): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.route !== undefined) {
      obj.route = Route.toJSON(message.route);
    }
    if (message.brigade !== undefined) {
      obj.brigade = message.brigade;
    }
    if (message.tripId !== undefined) {
      obj.tripId = message.tripId;
    }
    if (message.location?.length) {
      obj.location = message.location.map((e) => Math.round(e));
    }
    if (message.bearing !== undefined) {
      obj.bearing = message.bearing;
    }
    if (message.lastPing !== undefined) {
      obj.lastPing = Math.round(message.lastPing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vehicle>, I>>(base?: I): Vehicle {
    return Vehicle.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vehicle>, I>>(object: I): Vehicle {
    const message = createBaseVehicle();
    message.id = object.id ?? "";
    message.city = object.city ?? "";
    message.route = (object.route !== undefined && object.route !== null) ? Route.fromPartial(object.route) : undefined;
    message.brigade = object.brigade ?? undefined;
    message.tripId = object.tripId ?? undefined;
    message.location = object.location?.map((e) => e) || [];
    message.bearing = object.bearing ?? undefined;
    message.lastPing = object.lastPing ?? undefined;
    return message;
  },
};

function createBaseMapFeaturesUpdate(): MapFeaturesUpdate {
  return { vehicles: [], dotVehicles: undefined, stops: [], stopsChanged: false };
}

export const MapFeaturesUpdate: MessageFns<MapFeaturesUpdate> = {
  encode(message: MapFeaturesUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.vehicles) {
      Vehicle.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.dotVehicles !== undefined) {
      DotVehicles.encode(message.dotVehicles, writer.uint32(18).fork()).join();
    }
    for (const v of message.stops) {
      Stop.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.stopsChanged !== false) {
      writer.uint32(32).bool(message.stopsChanged);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapFeaturesUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapFeaturesUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vehicles.push(Vehicle.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dotVehicles = DotVehicles.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stops.push(Stop.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.stopsChanged = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapFeaturesUpdate {
    return {
      vehicles: globalThis.Array.isArray(object?.vehicles) ? object.vehicles.map((e: any) => Vehicle.fromJSON(e)) : [],
      dotVehicles: isSet(object.dotVehicles) ? DotVehicles.fromJSON(object.dotVehicles) : undefined,
      stops: globalThis.Array.isArray(object?.stops) ? object.stops.map((e: any) => Stop.fromJSON(e)) : [],
      stopsChanged: isSet(object.stopsChanged) ? globalThis.Boolean(object.stopsChanged) : false,
    };
  },

  toJSON(message: MapFeaturesUpdate): unknown {
    const obj: any = {};
    if (message.vehicles?.length) {
      obj.vehicles = message.vehicles.map((e) => Vehicle.toJSON(e));
    }
    if (message.dotVehicles !== undefined) {
      obj.dotVehicles = DotVehicles.toJSON(message.dotVehicles);
    }
    if (message.stops?.length) {
      obj.stops = message.stops.map((e) => Stop.toJSON(e));
    }
    if (message.stopsChanged !== false) {
      obj.stopsChanged = message.stopsChanged;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapFeaturesUpdate>, I>>(base?: I): MapFeaturesUpdate {
    return MapFeaturesUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapFeaturesUpdate>, I>>(object: I): MapFeaturesUpdate {
    const message = createBaseMapFeaturesUpdate();
    message.vehicles = object.vehicles?.map((e) => Vehicle.fromPartial(e)) || [];
    message.dotVehicles = (object.dotVehicles !== undefined && object.dotVehicles !== null)
      ? DotVehicles.fromPartial(object.dotVehicles)
      : undefined;
    message.stops = object.stops?.map((e) => Stop.fromPartial(e)) || [];
    message.stopsChanged = object.stopsChanged ?? false;
    return message;
  },
};

function createBaseDotVehicles(): DotVehicles {
  return { colors: [], vehicles: [] };
}

export const DotVehicles: MessageFns<DotVehicles> = {
  encode(message: DotVehicles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.colors) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.vehicles) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DotVehicles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDotVehicles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.colors.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.vehicles.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vehicles.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DotVehicles {
    return {
      colors: globalThis.Array.isArray(object?.colors) ? object.colors.map((e: any) => globalThis.String(e)) : [],
      vehicles: globalThis.Array.isArray(object?.vehicles) ? object.vehicles.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DotVehicles): unknown {
    const obj: any = {};
    if (message.colors?.length) {
      obj.colors = message.colors;
    }
    if (message.vehicles?.length) {
      obj.vehicles = message.vehicles.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DotVehicles>, I>>(base?: I): DotVehicles {
    return DotVehicles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DotVehicles>, I>>(object: I): DotVehicles {
    const message = createBaseDotVehicles();
    message.colors = object.colors?.map((e) => e) || [];
    message.vehicles = object.vehicles?.map((e) => e) || [];
    return message;
  },
};

function createBaseStopDeparturesUpdate(): StopDeparturesUpdate {
  return { stop: undefined, departures: [] };
}

export const StopDeparturesUpdate: MessageFns<StopDeparturesUpdate> = {
  encode(message: StopDeparturesUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stop !== undefined) {
      Stop.encode(message.stop, writer.uint32(10).fork()).join();
    }
    for (const v of message.departures) {
      DepartureEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StopDeparturesUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStopDeparturesUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stop = Stop.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.departures.push(DepartureEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StopDeparturesUpdate {
    return {
      stop: isSet(object.stop) ? Stop.fromJSON(object.stop) : undefined,
      departures: globalThis.Array.isArray(object?.departures)
        ? object.departures.map((e: any) => DepartureEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StopDeparturesUpdate): unknown {
    const obj: any = {};
    if (message.stop !== undefined) {
      obj.stop = Stop.toJSON(message.stop);
    }
    if (message.departures?.length) {
      obj.departures = message.departures.map((e) => DepartureEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StopDeparturesUpdate>, I>>(base?: I): StopDeparturesUpdate {
    return StopDeparturesUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StopDeparturesUpdate>, I>>(object: I): StopDeparturesUpdate {
    const message = createBaseStopDeparturesUpdate();
    message.stop = (object.stop !== undefined && object.stop !== null) ? Stop.fromPartial(object.stop) : undefined;
    message.departures = object.departures?.map((e) => DepartureEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDepartureEntry(): DepartureEntry {
  return { trip: undefined, departure: undefined, destination: undefined, position: undefined };
}

export const DepartureEntry: MessageFns<DepartureEntry> = {
  encode(message: DepartureEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trip !== undefined) {
      TripDetails.encode(message.trip, writer.uint32(10).fork()).join();
    }
    if (message.departure !== undefined) {
      DepartureEvent.encode(message.departure, writer.uint32(18).fork()).join();
    }
    if (message.destination !== undefined) {
      DepartureEvent.encode(message.destination, writer.uint32(26).fork()).join();
    }
    if (message.position !== undefined) {
      Vehicle.encode(message.position, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepartureEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepartureEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trip = TripDetails.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.departure = DepartureEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destination = DepartureEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = Vehicle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepartureEntry {
    return {
      trip: isSet(object.trip) ? TripDetails.fromJSON(object.trip) : undefined,
      departure: isSet(object.departure) ? DepartureEvent.fromJSON(object.departure) : undefined,
      destination: isSet(object.destination) ? DepartureEvent.fromJSON(object.destination) : undefined,
      position: isSet(object.position) ? Vehicle.fromJSON(object.position) : undefined,
    };
  },

  toJSON(message: DepartureEntry): unknown {
    const obj: any = {};
    if (message.trip !== undefined) {
      obj.trip = TripDetails.toJSON(message.trip);
    }
    if (message.departure !== undefined) {
      obj.departure = DepartureEvent.toJSON(message.departure);
    }
    if (message.destination !== undefined) {
      obj.destination = DepartureEvent.toJSON(message.destination);
    }
    if (message.position !== undefined) {
      obj.position = Vehicle.toJSON(message.position);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepartureEntry>, I>>(base?: I): DepartureEntry {
    return DepartureEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepartureEntry>, I>>(object: I): DepartureEntry {
    const message = createBaseDepartureEntry();
    message.trip = (object.trip !== undefined && object.trip !== null)
      ? TripDetails.fromPartial(object.trip)
      : undefined;
    message.departure = (object.departure !== undefined && object.departure !== null)
      ? DepartureEvent.fromPartial(object.departure)
      : undefined;
    message.destination = (object.destination !== undefined && object.destination !== null)
      ? DepartureEvent.fromPartial(object.destination)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? Vehicle.fromPartial(object.position)
      : undefined;
    return message;
  },
};

function createBaseTripDetails(): TripDetails {
  return { id: "", city: "", headsign: "", route: undefined, shortName: undefined, brigade: undefined };
}

export const TripDetails: MessageFns<TripDetails> = {
  encode(message: TripDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.city !== "") {
      writer.uint32(18).string(message.city);
    }
    if (message.headsign !== "") {
      writer.uint32(26).string(message.headsign);
    }
    if (message.route !== undefined) {
      Route.encode(message.route, writer.uint32(34).fork()).join();
    }
    if (message.shortName !== undefined) {
      writer.uint32(42).string(message.shortName);
    }
    if (message.brigade !== undefined) {
      writer.uint32(50).string(message.brigade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.headsign = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.route = Route.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shortName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.brigade = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripDetails {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      headsign: isSet(object.headsign) ? globalThis.String(object.headsign) : "",
      route: isSet(object.route) ? Route.fromJSON(object.route) : undefined,
      shortName: isSet(object.shortName) ? globalThis.String(object.shortName) : undefined,
      brigade: isSet(object.brigade) ? globalThis.String(object.brigade) : undefined,
    };
  },

  toJSON(message: TripDetails): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.headsign !== "") {
      obj.headsign = message.headsign;
    }
    if (message.route !== undefined) {
      obj.route = Route.toJSON(message.route);
    }
    if (message.shortName !== undefined) {
      obj.shortName = message.shortName;
    }
    if (message.brigade !== undefined) {
      obj.brigade = message.brigade;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TripDetails>, I>>(base?: I): TripDetails {
    return TripDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TripDetails>, I>>(object: I): TripDetails {
    const message = createBaseTripDetails();
    message.id = object.id ?? "";
    message.city = object.city ?? "";
    message.headsign = object.headsign ?? "";
    message.route = (object.route !== undefined && object.route !== null) ? Route.fromPartial(object.route) : undefined;
    message.shortName = object.shortName ?? undefined;
    message.brigade = object.brigade ?? undefined;
    return message;
  },
};

function createBaseDepartureEvent(): DepartureEvent {
  return { scheduled: 0, predicted: 0, status: 0, platform: undefined };
}

export const DepartureEvent: MessageFns<DepartureEvent> = {
  encode(message: DepartureEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduled !== 0) {
      writer.uint32(8).int64(message.scheduled);
    }
    if (message.predicted !== 0) {
      writer.uint32(16).int64(message.predicted);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.platform !== undefined) {
      writer.uint32(34).string(message.platform);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DepartureEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDepartureEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scheduled = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.predicted = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DepartureEvent {
    return {
      scheduled: isSet(object.scheduled) ? globalThis.Number(object.scheduled) : 0,
      predicted: isSet(object.predicted) ? globalThis.Number(object.predicted) : 0,
      status: isSet(object.status) ? departureStatusFromJSON(object.status) : 0,
      platform: isSet(object.platform) ? globalThis.String(object.platform) : undefined,
    };
  },

  toJSON(message: DepartureEvent): unknown {
    const obj: any = {};
    if (message.scheduled !== 0) {
      obj.scheduled = Math.round(message.scheduled);
    }
    if (message.predicted !== 0) {
      obj.predicted = Math.round(message.predicted);
    }
    if (message.status !== 0) {
      obj.status = departureStatusToJSON(message.status);
    }
    if (message.platform !== undefined) {
      obj.platform = message.platform;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DepartureEvent>, I>>(base?: I): DepartureEvent {
    return DepartureEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DepartureEvent>, I>>(object: I): DepartureEvent {
    const message = createBaseDepartureEvent();
    message.scheduled = object.scheduled ?? 0;
    message.predicted = object.predicted ?? 0;
    message.status = object.status ?? 0;
    message.platform = object.platform ?? undefined;
    return message;
  },
};

function createBaseTripUpdateData(): TripUpdateData {
  return {
    city: "",
    trip: undefined,
    shape: undefined,
    vehicle: undefined,
    stops: [],
    sequence: undefined,
    lastUpdate: undefined,
  };
}

export const TripUpdateData: MessageFns<TripUpdateData> = {
  encode(message: TripUpdateData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.city !== "") {
      writer.uint32(10).string(message.city);
    }
    if (message.trip !== undefined) {
      TripDetails.encode(message.trip, writer.uint32(18).fork()).join();
    }
    if (message.shape !== undefined) {
      writer.uint32(26).string(message.shape);
    }
    if (message.vehicle !== undefined) {
      Vehicle.encode(message.vehicle, writer.uint32(34).fork()).join();
    }
    for (const v of message.stops) {
      TripStop.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.sequence !== undefined) {
      writer.uint32(48).int32(message.sequence);
    }
    if (message.lastUpdate !== undefined) {
      writer.uint32(56).int64(message.lastUpdate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripUpdateData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripUpdateData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.city = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trip = TripDetails.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shape = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vehicle = Vehicle.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.stops.push(TripStop.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sequence = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastUpdate = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripUpdateData {
    return {
      city: isSet(object.city) ? globalThis.String(object.city) : "",
      trip: isSet(object.trip) ? TripDetails.fromJSON(object.trip) : undefined,
      shape: isSet(object.shape) ? globalThis.String(object.shape) : undefined,
      vehicle: isSet(object.vehicle) ? Vehicle.fromJSON(object.vehicle) : undefined,
      stops: globalThis.Array.isArray(object?.stops) ? object.stops.map((e: any) => TripStop.fromJSON(e)) : [],
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : undefined,
      lastUpdate: isSet(object.lastUpdate) ? globalThis.Number(object.lastUpdate) : undefined,
    };
  },

  toJSON(message: TripUpdateData): unknown {
    const obj: any = {};
    if (message.city !== "") {
      obj.city = message.city;
    }
    if (message.trip !== undefined) {
      obj.trip = TripDetails.toJSON(message.trip);
    }
    if (message.shape !== undefined) {
      obj.shape = message.shape;
    }
    if (message.vehicle !== undefined) {
      obj.vehicle = Vehicle.toJSON(message.vehicle);
    }
    if (message.stops?.length) {
      obj.stops = message.stops.map((e) => TripStop.toJSON(e));
    }
    if (message.sequence !== undefined) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.lastUpdate !== undefined) {
      obj.lastUpdate = Math.round(message.lastUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TripUpdateData>, I>>(base?: I): TripUpdateData {
    return TripUpdateData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TripUpdateData>, I>>(object: I): TripUpdateData {
    const message = createBaseTripUpdateData();
    message.city = object.city ?? "";
    message.trip = (object.trip !== undefined && object.trip !== null)
      ? TripDetails.fromPartial(object.trip)
      : undefined;
    message.shape = object.shape ?? undefined;
    message.vehicle = (object.vehicle !== undefined && object.vehicle !== null)
      ? Vehicle.fromPartial(object.vehicle)
      : undefined;
    message.stops = object.stops?.map((e) => TripStop.fromPartial(e)) || [];
    message.sequence = object.sequence ?? undefined;
    message.lastUpdate = object.lastUpdate ?? undefined;
    return message;
  },
};

function createBaseTripStop(): TripStop {
  return {
    stop: undefined,
    arrival: undefined,
    departure: undefined,
    sequence: 0,
    type: 0,
    platform: undefined,
    track: undefined,
    alerts: [],
  };
}

export const TripStop: MessageFns<TripStop> = {
  encode(message: TripStop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.stop !== undefined) {
      Stop.encode(message.stop, writer.uint32(10).fork()).join();
    }
    if (message.arrival !== undefined) {
      TripTime.encode(message.arrival, writer.uint32(18).fork()).join();
    }
    if (message.departure !== undefined) {
      TripTime.encode(message.departure, writer.uint32(26).fork()).join();
    }
    if (message.sequence !== 0) {
      writer.uint32(32).int32(message.sequence);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.platform !== undefined) {
      writer.uint32(50).string(message.platform);
    }
    if (message.track !== undefined) {
      writer.uint32(58).string(message.track);
    }
    for (const v of message.alerts) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripStop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripStop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.stop = Stop.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arrival = TripTime.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.departure = TripTime.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.sequence = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.platform = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.track = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.alerts.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripStop {
    return {
      stop: isSet(object.stop) ? Stop.fromJSON(object.stop) : undefined,
      arrival: isSet(object.arrival) ? TripTime.fromJSON(object.arrival) : undefined,
      departure: isSet(object.departure) ? TripTime.fromJSON(object.departure) : undefined,
      sequence: isSet(object.sequence) ? globalThis.Number(object.sequence) : 0,
      type: isSet(object.type) ? stopTimeTypeFromJSON(object.type) : 0,
      platform: isSet(object.platform) ? globalThis.String(object.platform) : undefined,
      track: isSet(object.track) ? globalThis.String(object.track) : undefined,
      alerts: globalThis.Array.isArray(object?.alerts) ? object.alerts.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: TripStop): unknown {
    const obj: any = {};
    if (message.stop !== undefined) {
      obj.stop = Stop.toJSON(message.stop);
    }
    if (message.arrival !== undefined) {
      obj.arrival = TripTime.toJSON(message.arrival);
    }
    if (message.departure !== undefined) {
      obj.departure = TripTime.toJSON(message.departure);
    }
    if (message.sequence !== 0) {
      obj.sequence = Math.round(message.sequence);
    }
    if (message.type !== 0) {
      obj.type = stopTimeTypeToJSON(message.type);
    }
    if (message.platform !== undefined) {
      obj.platform = message.platform;
    }
    if (message.track !== undefined) {
      obj.track = message.track;
    }
    if (message.alerts?.length) {
      obj.alerts = message.alerts;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TripStop>, I>>(base?: I): TripStop {
    return TripStop.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TripStop>, I>>(object: I): TripStop {
    const message = createBaseTripStop();
    message.stop = (object.stop !== undefined && object.stop !== null) ? Stop.fromPartial(object.stop) : undefined;
    message.arrival = (object.arrival !== undefined && object.arrival !== null)
      ? TripTime.fromPartial(object.arrival)
      : undefined;
    message.departure = (object.departure !== undefined && object.departure !== null)
      ? TripTime.fromPartial(object.departure)
      : undefined;
    message.sequence = object.sequence ?? 0;
    message.type = object.type ?? 0;
    message.platform = object.platform ?? undefined;
    message.track = object.track ?? undefined;
    message.alerts = object.alerts?.map((e) => e) || [];
    return message;
  },
};

function createBaseTripTime(): TripTime {
  return { scheduled: 0, predicted: 0, status: 0 };
}

export const TripTime: MessageFns<TripTime> = {
  encode(message: TripTime, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduled !== 0) {
      writer.uint32(8).int64(message.scheduled);
    }
    if (message.predicted !== 0) {
      writer.uint32(16).int64(message.predicted);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripTime {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripTime();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scheduled = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.predicted = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripTime {
    return {
      scheduled: isSet(object.scheduled) ? globalThis.Number(object.scheduled) : 0,
      predicted: isSet(object.predicted) ? globalThis.Number(object.predicted) : 0,
      status: isSet(object.status) ? departureStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: TripTime): unknown {
    const obj: any = {};
    if (message.scheduled !== 0) {
      obj.scheduled = Math.round(message.scheduled);
    }
    if (message.predicted !== 0) {
      obj.predicted = Math.round(message.predicted);
    }
    if (message.status !== 0) {
      obj.status = departureStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TripTime>, I>>(base?: I): TripTime {
    return TripTime.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TripTime>, I>>(object: I): TripTime {
    const message = createBaseTripTime();
    message.scheduled = object.scheduled ?? 0;
    message.predicted = object.predicted ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
